/**
 * @file preprocess.c
 * @author Da'Jour J. Christophe (dajour.christophe@gmail.com)
 * @brief
 * @version 0.1
 * @date 2023-04-30
 *
 * @copyright Copyright (c) 2023 Da'Jour J. Christophe. All rights reserved.
 */
#include "common.h"

#include <sqlite3.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NAME_COLUMN_LENGTH 64

static char **buffer = NULL;
static size_t buffer_size = 0;

static void buffer_destroy(void)
{
  for (int i = 0; i < buffer_size; i++)
  {
    __free(buffer[i]);
  }
  __free(buffer);
}

static int callback(void *NotUsed, int argc, char **argv, char **azColName)
{
  NotUsed = 0;

  for (int i = 0; i < argc; i++)
  {
    buffer[buffer_size] = __calloc(MAX_NAME_COLUMN_LENGTH, sizeof(char));
    strcpy(buffer[buffer_size++], argv[i] ? argv[i] : "");
  }

  return 0;
}

static int fetch_definitions_from_database(const char *fp)
{
  sqlite3 *db;
  sqlite3_stmt *res;
  char *err_msg = 0;
  int rc;

  rc = sqlite3_open(fp, &db);
  if (rc != SQLITE_OK)
  {
    fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(db));
    sqlite3_close(db);
    return EXIT_FAILURE;
  }

  buffer = __calloc(128, sizeof(char *));

  const char query[] = "select name from definition";
  rc = sqlite3_exec(db, query, callback, 0, &err_msg);
  if (rc != SQLITE_OK)
  {
    fprintf(stderr, "Failed to select data\n");
    fprintf(stderr, "SQL error: %s\n", err_msg);
    sqlite3_free(err_msg);
    sqlite3_close(db);
    return EXIT_FAILURE;
  }

  sqlite3_close(db);
  return EXIT_SUCCESS;
}

static char *create_enum(void)
{
  char *output = NULL;
  char tmp[1024];
  int n;

  output = __calloc(4096, sizeof(char));

  strncpy(output, "/* **WARNING** DO NOT EDIT THIS FILE! THIS FILE WAS GENERATED BY THE BUILD. */\n#ifndef X_SYNTAX_FACTS_H\n#define X_SYNTAX_FACTS_H\n\nenum\n{\n", 138);

  for (int i = 0; i < buffer_size; i++)
  {
    memset(tmp, 0, 1024 * sizeof(char));
    n = sprintf(tmp, "  %s,\n", buffer[i]);
    strncat(output, tmp, n);
  }

  strncat(output, "};\n\n#endif/*X_SYNTAX_FACTS_H*/\n", 32);

  buffer_destroy();
  buffer_size = 0;

  return output;
}

int main(void)
{
  const char database[] = "tmp/db/syntax.sqlite3";
  char *output = NULL;
  int rc;

  rc = fetch_definitions_from_database(database);
  if (rc != EXIT_SUCCESS)
  {
    fprintf(stderr, "%s\n", "failed to fetch syntax token definitions from the local database");
    return EXIT_FAILURE;
  }

  output = create_enum();

  FILE *fd;
  fd = fopen("include/facts.h", "wb");
  if (fd == NULL)
  {
    fprintf(stderr, "%s\n", "file couldn't be opened");
    exit(EXIT_FAILURE);
  }

  const size_t n = fwrite(output, 1, strlen(output), fd);
  printf("bytes written into file are : %d\n", n);
  __free(output);
  fclose(fd);

  return EXIT_SUCCESS;
}
